<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="initial-scale=1.0, user-scalable=no" />
    <title>Drag and Drop GeoJSON</title>
    <style type="text/css">
      html { height: 100% }
      body { height: 100%; margin: 0; padding: 0; overflow: hidden; }
      #map-canvas { height: 100% }
      #drop-container {
        display: none;
        height: 100%;
        width: 100%;
        position: absolute;
        z-index: 1;
        top: 0px;
        left: 0px;
        padding: 20px;
        background-color: rgba(100, 100, 100, 0.5);
      }
      #drop-silhouette {
        color: white;
        border: white dashed 8px;
        height: calc(100% - 56px);
        width: calc(100% - 56px);
        background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAYAAABw4pVUAAAAAXNSR0IArs4c6QAAAAZiS0dEAGQAZABkkPCsTwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB90LHAIvICWdsKwAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAACdklEQVR42u3csU7icBzA8Xp3GBMSeRITH8JHMY7cRMvmVmXoE9TAcJubhjD4ApoiopgqDMWAKAgIcSAiCfxuwhwROVJbkPD9rP23ob8vpZCQKgoAAAAAAAAAAPDYyiK/eNM05bNtr6+vSjgcXiHxDMkE1WpVFvGcfpCVICAIQUAQgoAgBAFBCAKCgCAEAUEIAoIQBAQhCAgCghAEBCEICEIQEIQgIAgIQhAQhCAgCEFAEIKAICAIQUAQgoAgBAFBCDIzhmFINBo9/K6D0XVddnd3ZaneDY7jSCqVcn3SfjyeKRKJbJ2dnYllWbKUl2i5XJaXlxdJJBIy7yDHx8fy9vYm6XR6OWMM3d/fi4hIqVSSWCwmsw5ycHAgrVZLRETOz8+XO8ZQpVJ5H2Y6nRZN0/b9DqLruhSLxfd9MpkMMT6L0uv1JJlMih9BhveJwWDwvv7i4oIY4zw8PIwMtt1uSzweF6+CHB0dSbfbHVmbzWaJMcnj4+OHAd/d3cne3p64DWKapjw/P39Yd3l5SYxpVKvVsYO2LEtUVd2ZNoiu6+I4ztg1V1dXxPAiSq/Xk5OTk0k9pNVqyenp6ch94l+5XI4YbtRqNfHa9fX1t43xcwGa/Nnc3PwdDAY9OZht28rGxgZPvP6KSCSy9fT09OUrw7ZtPqa8jFKv113HuLm5IYbXVFXdcRPl9vaWGH5GaTQaU8fI5/PE8JumafvNZvO/MQqFAjFmJRqNHk6Ksqgx5vr1zzAM2d7edr3/6uqqsra2NnZbp9NR+v2+62OHQqG5zObXPIMEAgFlfX3dl2N79btl1viTA0FAEIKAIAQBAAAAAAAAsMz+Ai1bUgo6ebm8AAAAAElFTkSuQmCC');
        background-repeat: no-repeat;
        background-position: center;
      }
    </style>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/css/bootstrap.min.css">
    <script type="text/javascript" src="/static/js/jquery.min.js"></script>
    <script src="https://maps.googleapis.com/maps/api/js?v=3.exp"></script>
    <script type="text/javascript">
/* Map functions */

var map;

function initMap() {
  // set up the map
  map = new google.maps.Map(document.getElementById('map-canvas'), {
    center: new google.maps.LatLng(0, 0),
    zoom: 2
  });
}

function loadGeoJsonString(geoString) {
  var geojson = JSON.parse(geoString);
  return loadGeoJson(geojson);
}

function loadGeoJson(geometry) {
  var feature = {
    type: "Feature",
    id: 0,
    geometry: geometry,
  }
  var res = map.data.addGeoJson(feature);
  zoom(map);
  return res
}

/**
 * Update a map's viewport to fit each geometry in a dataset
 * @param {google.maps.Map} map The map to adjust
 */
function zoom(map) {
  var bounds = new google.maps.LatLngBounds();
  map.data.forEach(function(feature) {
    processPoints(feature.getGeometry(), bounds.extend, bounds);
  });
  map.fitBounds(bounds);
}

/**
 * Process each point in a Geometry, regardless of how deep the points may lie.
 * @param {google.maps.Data.Geometry} geometry The structure to process
 * @param {function(google.maps.LatLng)} callback A function to call on each
 *     LatLng point encountered (e.g. Array.push)
 * @param {Object} thisArg The value of 'this' as provided to 'callback' (e.g.
 *     myArray)
 */
function processPoints(geometry, callback, thisArg) {
  if (geometry instanceof google.maps.LatLng) {
    callback.call(thisArg, geometry);
  } else if (geometry instanceof google.maps.Data.Point) {
    callback.call(thisArg, geometry.get());
  } else {
    geometry.getArray().forEach(function(g) {
      processPoints(g, callback, thisArg);
    });
  }
}


/* DOM (drag/drop) functions */

function initEvents() {
  // set up the drag & drop events
  var mapContainer = document.getElementById('map-canvas');
  var dropContainer = document.getElementById('drop-container');

  // first on common events
  [mapContainer, dropContainer].forEach(function(container) {
    container.addEventListener('drop', handleDrop, false);
    container.addEventListener('dragover', showPanel, false);
  });

  // then map-specific events
  mapContainer.addEventListener('dragstart', showPanel, false);
  mapContainer.addEventListener('dragenter', showPanel, false);

  // then the overlay specific events (since it only appears once drag starts)
  dropContainer.addEventListener('dragend', hidePanel, false);
  dropContainer.addEventListener('dragleave', hidePanel, false);
}

function showPanel(e) {
  e.stopPropagation();
  e.preventDefault();
  document.getElementById('drop-container').style.display = 'block';
  return false;
}

function hidePanel(e) {
  document.getElementById('drop-container').style.display = 'none';
}

function handleDrop(e) {
  e.preventDefault();
  e.stopPropagation();
  hidePanel(e);

  var files = e.dataTransfer.files;
  if (files.length) {
    // process file(s) being dropped
    // grab the file data from each file
    for (var i = 0, file; file = files[i]; i++) {
      var reader = new FileReader();
      reader.onload = function(e) {
        loadGeoJsonString(e.target.result);
      };
      reader.onerror = function(e) {
        console.error('reading failed');
      };
      reader.readAsText(file);
    }
  } else {
    // process non-file (e.g. text or html) content being dropped
    // grab the plain text version of the data
    var plainText = e.dataTransfer.getData('text/plain');
    if (plainText) {
      loadGeoJsonString(plainText);
    }
  }

  // prevent drag event from bubbling further
  return false;
}

// { type: "Annulus", center: [lng, lat], min: 0, max: 10 /* meters */ }

function ShapeAndCovering(id) {
  // query GeoJSON or Annnulas
  this.shape = null;
  // Array of GeoJSON, each polygon represents a cell
  this.covering = [];
  this.id = id;
  // Features to diplay
}

function get2dSphereField(stage) {
  if (stage.stage != "IXSCAN") return null;
  keyPattern = stage.keyPattern;
  if (keyPattern == null) return null;
  var res = null;
  Object.getOwnPropertyNames(keyPattern).forEach(function(field) {
    if (keyPattern[field] == "2dsphere") {
      res = field;
    }})

  return res;
}

function findField(node, expectedField) {
  res = null;
  if (node === null || typeof node !== 'object') {
    return null;
  }

  nodeKeys = Object.getOwnPropertyNames(node);
  for (i = 0; i < nodeKeys.length; i++) {
    field = nodeKeys[i];
    if (field == expectedField) {
      return node[field];
    } else {
      res = findField(node[field], expectedField);
    }
  }
  return res;
}

// bounds is the array of string
// [
//   "[\"0f1332332\", \"0f1332332\"]",
//   "[\"0f13323323\", \"0f13323323\"]",
// ]
function translateIndexBoundsToGeoJSON(bounds, processCovering) {
  // Only show intervals, no points
  var startRe = /\"(\w*)\".*\)$/;
  var cells = [];
  bounds.forEach(function(bound) {
    var m = startRe.exec(bound);
    if (m) cells.push(m[1]);
  });
  // cells ["0f1332332", "0f13323323"]
  $.post("/parse_cells", {cells: JSON.stringify(cells)}, function(data) {
    // console.log(data);
    processCovering(data.polygons);
  });
}

function showGeoQueryExplain(shapeAndCovering) {
  loadGeoJson(shapeAndCovering.shape);
  shapeAndCovering.covering.forEach(function(polygon) {
    loadGeoJson(polygon);
  });
}

function parseGeoQueryExplain(explain_text) {
  var explain = JSON.parse(explain_text);
  var stage = explain.executionStats.executionStages;
  // TODO: inputStage / executionStats maybe an array.
  while (stage != null && get2dSphereField(stage) == null) {
    stage = stage.inputStage;
  }

  if (stage == null) {
    console.log("cannot find IXSCAN stage in parseGeoQueryExplain");
    return;
  }

  var geoField = get2dSphereField(stage);
  // Convert stage.indexBounds
  translateIndexBoundsToGeoJSON(stage.indexBounds[geoField], function(covering) {
    shapeAndCovering = new ShapeAndCovering(0);
    shapeAndCovering.covering = covering;
    shapeAndCovering.shape = findField(explain.queryPlanner.parsedQuery, "$geometry");
    showGeoQueryExplain(shapeAndCovering);
  });
}

google.maps.event.addDomListener(window, 'load', function() {
  initMap();
  initEvents();
});

$(document).ready(function() {
   $('#show_button').click(function() {
      parseGeoQueryExplain($('#explain_text').val());
   })
});

    </script>
  </head>
  <body>
    <div>
      <textarea class="form-control" id="explain_text" cols="30" rows="10">
{"queryPlanner":{"plannerVersion":1,"namespace":"test.geogeo","indexFilterSet":false,"parsedQuery":{"loc":{"$geoWithin":{"$geometry":{"type":"Polygon","coordinates":[[[-73.98784,40.75747],[-73.93784,40.65747],[-74.01784,40.63747],[-73.98784,40.75747]]]}}}},"winningPlan":{"stage":"KEEP_MUTATIONS","inputStage":{"stage":"FETCH","filter":{"loc":{"$geoWithin":{"$geometry":{"type":"Polygon","coordinates":[[[-73.98784,40.75747],[-73.93784,40.65747],[-74.01784,40.63747],[-73.98784,40.75747]]]}}}},"inputStage":{"stage":"IXSCAN","keyPattern":{"loc":"2dsphere"},"indexName":"loc_2dsphere","isMultiKey":false,"indexVersion":1,"direction":"forward","indexBounds":{"loc":["[\"4f1032010\", \"4f1032010\"]","[\"4f10320102\", \"4f10320102\"]","[\"4f103201020\", \"4f103201020\"]","[\"4f1032010202\", \"4f1032010202\"]","[\"4f10320102022\", \"4f10320102023\")","[\"4f103201023\", \"4f103201023\"]","[\"4f1032010230\", \"4f1032010230\"]","[\"4f10320102300\", \"4f10320102301\")","[\"4f10320102302\", \"4f10320102303\")","[\"4f10320102303\", \"4f10320102304\")","[\"4f1032010231\", \"4f1032010232\")"]}}}},"rejectedPlans":[]},"executionStats":{"executionSuccess":true,"nReturned":0,"executionTimeMillis":6,"totalKeysExamined":0,"totalDocsExamined":0,"executionStages":{"stage":"KEEP_MUTATIONS","nReturned":0,"executionTimeMillisEstimate":0,"works":1,"advanced":0,"needTime":0,"needYield":0,"saveState":0,"restoreState":0,"isEOF":1,"invalidates":0,"inputStage":{"stage":"FETCH","filter":{"loc":{"$geoWithin":{"$geometry":{"type":"Polygon","coordinates":[[[-73.98784,40.75747],[-73.93784,40.65747],[-74.01784,40.63747],[-73.98784,40.75747]]]}}}},"nReturned":0,"executionTimeMillisEstimate":0,"works":1,"advanced":0,"needTime":0,"needYield":0,"saveState":0,"restoreState":0,"isEOF":1,"invalidates":0,"docsExamined":0,"alreadyHasObj":0,"inputStage":{"stage":"IXSCAN","nReturned":0,"executionTimeMillisEstimate":0,"works":1,"advanced":0,"needTime":0,"needYield":0,"saveState":0,"restoreState":0,"isEOF":1,"invalidates":0,"keyPattern":{"loc":"2dsphere"},"indexName":"loc_2dsphere","isMultiKey":false,"indexVersion":1,"direction":"forward","indexBounds":{"loc":["[\"4f1032010\", \"4f1032010\"]","[\"4f10320102\", \"4f10320102\"]","[\"4f103201020\", \"4f103201020\"]","[\"4f1032010202\", \"4f1032010202\"]","[\"4f10320102022\", \"4f10320102023\")","[\"4f103201023\", \"4f103201023\"]","[\"4f1032010230\", \"4f1032010230\"]","[\"4f10320102300\", \"4f10320102301\")","[\"4f10320102302\", \"4f10320102303\")","[\"4f10320102303\", \"4f10320102304\")","[\"4f1032010231\", \"4f1032010232\")"]},"keysExamined":0,"dupsTested":0,"dupsDropped":0,"seenInvalidated":0,"matchTested":0}}},"allPlansExecution":[]},"serverInfo":{"host":"siyuan-mbp","port":27017,"version":"3.1.0-pre-","gitVersion":"ed108dccf043a13e1eed08dafc6c9eb793094b34"},"ok":1}
</textarea>
      <button id="show_button" type="submit" class="btn btn-primary">Show<span class="glyphicon glyphicon-map-marker"/></button>
    </div>

    <div id="map-canvas"></div>
    <div id="drop-container"><div id="drop-silhouette"></div></div>
  </body>
</html>
